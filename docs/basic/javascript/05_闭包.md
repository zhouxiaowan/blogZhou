---
title: 闭包
date: 2021-11-18 12:30:55
lastUpdated: 2021-11-18 12:30:55
---

# 闭包
## 5.1 什么是闭包
闭包是基于词法作用域书写时所产生的自然结果。  
内部函数能够访问外部函数的内部作用域，并将内部函数当作一个值进行传递。  
下面通过分析一段代码来理解闭包
```js
function foo(){
  var a = 2
  function bar(){
    console.log(a)
  }
  return bar
}
var baz = foo() // foo()执行后，其返回值bar()函数赋值给变量baz
baz() // 2
```
在foo执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不在使用的内存空间。闭包的神奇之处在于可以阻止foo的内部作用域被回收。bar()依然持有对该作用的引用。  
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用。  
## 5.2 为什么要使用闭包
* 在函数外能够读取到函数内部的局部变量
* 可以让这些变量始终保存在内存中  

定时器、事件监听器、ajax回调或者其它的异步或者同步任务中，只要使用了回调，就可能用到了闭包
## 5.3 闭包的缺点
* 因为使用闭包后，变量得不到释放，所以会占用内存。不能滥用，否则影响网页的性能
* 内存泄漏
## 5.4 练习题
练习题：
```js
// 经典的，最常见的例子
for(var i = 1;i <= 5;i++){
  setTimeout(function timer(){
    console.log(i)
  },i*1000)
}
// 输出了5次6
// 我们可以通过一下修改让它输出1，2，3，4，5
for(var i = 1;i <= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    },j*1000)
  })(i) // 立即执行函数会为每一个迭代都生成一个新的作用域，使得函数回调可以将新的作用域封闭在每个迭代内部
}
```
```js
function f1(){
  var n=999;
  nAdd=function(){n+=1} // 如果在这里加上var，那个nAdd就是局部变量，如果没有var，那就是全局变量
  function f2(){
    alert(n);
  }
  return f2;
}
var result=f1();
result(); // 999
nAdd(); // 全局变量nAdd，在执行f1()后，赋值为function(){n+=1}，所以可以直接执行
result(); // 1000
```
